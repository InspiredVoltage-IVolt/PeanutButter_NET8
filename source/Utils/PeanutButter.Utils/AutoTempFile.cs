using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using _Path = System.IO.Path;

namespace PeanutButter.Utils
{
    /// <summary>
    /// Provides a mechanism to create, read and write a temporary file which
    /// is automatically removed at disposal time
    /// </summary>
    public class AutoTempFile : IDisposable
    {
        /// <summary>
        /// Provides the path to the temporary file on disk
        /// </summary>
        public string Path => _tempFile;

        /// <summary>
        /// Reads and writes binary data from and to the file
        /// </summary>
        public byte[] BinaryData
        {
            get => File.ReadAllBytes(_tempFile);
            set => File.WriteAllBytes(_tempFile, value);
        }

        /// <summary>
        /// Reads and writes string data from and to the file
        /// </summary>
        public string StringData
        {
            get => Encoding.UTF8.GetString(File.ReadAllBytes(_tempFile));
            set => File.WriteAllBytes(_tempFile, Encoding.UTF8.GetBytes(value ?? string.Empty));
        }

        private string _tempFile;
        private AutoDeleter _actual;
        private readonly object _lock = new object();

        /// <summary>
        /// Default constructor: creates the temp file with no data and no naming hints
        /// using the OS-level temporary filename generator.
        /// </summary>
        public AutoTempFile() : this(_Path.GetTempPath(), null, null)
        {
        }

        /// <summary>
        /// Constructs a new AutoTempFile with the provided binary data. The file
        /// name is generated by the operating system.
        /// </summary>
        /// <param name="data"></param>
        public AutoTempFile(byte[] data) : this(_Path.GetTempPath(), null, data)
        {
        }

        /// <summary>
        /// Constructs a new AutoTempFile with the provided string data. The file
        /// name is generated by the operating system.
        /// </summary>
        /// <param name="data"></param>
        public AutoTempFile(string data) : this(_Path.GetTempPath(), null, Encoding.UTF8.GetBytes(data))
        {
        }

        /// <summary>
        /// Constructs a new AutoTempFile in the specified baseFolder with the provided string data
        /// </summary>
        /// <param name="baseFolder">Folder to create the file within</param>
        /// <param name="data">String data to initialize the file with</param>
        public AutoTempFile(string baseFolder, string data) : this(baseFolder, null,
            Encoding.UTF8.GetBytes(data ?? string.Empty))
        {
        }

        /// <summary>
        /// Constructs a new AutoTempFile in the specified baseFolder with the provided binary data
        /// </summary>
        /// <param name="baseFolder">Folder to create the file within</param>
        /// <param name="data">Binary data to initialize the file with</param>
        public AutoTempFile(string baseFolder, byte[] data) : this(baseFolder, null, data)
        {
        }

        /// <summary>
        /// Constructs a new AutoTempFile in the provided folder with the provided
        /// name, containing the provided binary data
        /// </summary>
        /// <param name="baseFolder">Folder to create the file within</param>
        /// <param name="fileName">Name to use for the file</param>
        /// <param name="data">Binary data to initialize the file with</param>
        public AutoTempFile(string baseFolder, string fileName, byte[] data)
        {
            SetTempFileNameWith(baseFolder, fileName);
            _actual = new AutoDeleter(_tempFile);
            baseFolder = _Path.GetDirectoryName(_tempFile) ?? string.Empty;
            if (!Directory.Exists(baseFolder))
                Directory.CreateDirectory(baseFolder);
            File.WriteAllBytes(_tempFile, data ?? new byte[] { });
        }

        private readonly List<Func<string, string, string>> _fileNameStrategies =
            new List<Func<string, string, string>>()
            {
                FileNameWhenFolderAndFileNotSpecified,
                FileNameWhenFolderSpecifiedAndFileNotSpecified,
                FileNameWhenFolderNotSpecifiedAndFileIsSpecified,
                _Path.Combine
            };

        private static string FileNameWhenFolderNotSpecifiedAndFileIsSpecified(string folder, string file)
        {
            return folder == null && file != null
                ? _Path.Combine(_Path.GetTempPath(), file)
                : null;
        }

        private static string FileNameWhenFolderSpecifiedAndFileNotSpecified(string folder, string file)
        {
            return folder != null && file == null
                ? GetNewFileNameUnder(folder)
                : null;
        }

        private static string GetNewFileNameUnder(string folder)
        {
            string fileName;
            do
            {
                var tempFile = GetFileNameOfNewTempFile();
                fileName = _Path.Combine(folder, tempFile);
            } while (File.Exists(fileName));

            return fileName;
        }

        private static string GetFileNameOfNewTempFile()
        {
            var tempFileName = _Path.GetTempFileName();
            File.Delete(tempFileName);
            return _Path.GetFileName(tempFileName);
        }

        private static string FileNameWhenFolderAndFileNotSpecified(string folder, string file)
        {
            return folder == null && file == null
                ? _Path.GetTempFileName()
                : null;
        }

        private void SetTempFileNameWith(string baseFolder, string fileName)
        {
            _tempFile = _fileNameStrategies
                .Select(strategy => strategy(baseFolder, fileName))
                .First(path => path != null);
        }

        /// <inheritdoc />
        public void Dispose()
        {
            lock (_lock)
            {
                _actual?.Dispose();
                _actual = null;
            }
        }
    }
}